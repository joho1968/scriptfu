#!/usr/bin/env python3
"""
pflogpy.py

This script parses a Postfix mail log to summarize daily mail flow.

It produces a report similar to pflogsumm that includes:
  - Total messages processed (sent, deferred, bounced)
  - Rejected messages and connection attempts
  - Hourly distribution of mail events (optional)
  - Top senders and recipients

Features:
  - Accepts the date input on the command line in either YYYYMMDD or YYYY-MM-DD format,
    but still relies on the standard Postfix log timestamp format for parsing logs.
  - Option to skip report generation if no mail was processed.
  - Option to send the report via email with both plaintext and HTML parts. The HTML part
    displays the text report using a monospace font.
  - Optional command-line parameter to exclude the "Messages per Hour" section.

Usage:
  python postfix_mail_report.py --logfile /var/log/mail.log --date 2021-11-01 \
         [--skip-no-mail] [--email recipient@example.com] [--sender sender@example.com] \
         [--exclude-hourly]

Dependencies:
  - matplotlib (for plotting)

Notes:
  Adjust SMTP configuration as needed. This example assumes a local SMTP server.


This code was partially generated by an "AI" or "LLM" tool, and tweaked by
Joaquim Homrighausen, somewhere in Sweden, sometime in 2025 :-)
"""

import argparse
import re
import datetime
import sys
import io
import matplotlib.pyplot as plt
import smtplib
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from collections import Counter

def parse_args():
    parser = argparse.ArgumentParser(description='Summarize Postfix mail logs like pflogsumm.')
    parser.add_argument('--logfile', required=True, help='Path to the Postfix log file.')
    # Allow command-line date parameter as either YYYYMMDD or YYYY-MM-DD.
    parser.add_argument('--date', required=True,
                        help='Date for report in either YYYYMMDD or YYYY-MM-DD format.')
    parser.add_argument('--skip-no-mail', action='store_true',
                        help='Do not create a report if there is no mail processed for the day.')
    parser.add_argument('--email', help='Email address to send the report to.')
    parser.add_argument('--sender', default='postfix-report@example.com',
                        help='Sender email address when mailing report.')
    parser.add_argument('--exclude-hourly', action='store_true',
                        help='Exclude the "Messages per Hour" section from the report.')
    return parser.parse_args()


def parse_log_file(logfile, target_date):
    """
    Parse the given logfile to extract mail events for the target_date.

    Note:
      The target_date input is provided by the user in YYYYMMDD or YYYY-MM-DD format.
      We convert it into a datetime object and then use its month abbreviation and day
      (as expected by Postfix log entries) to match lines in the log file.

    The summary dictionary contains:
      - 'sent', 'deferred', 'bounced', 'rejected': Counters of events.
      - 'connections': Number of SMTP connection attempts.
      - 'per_hour': A counter mapping hour (00-23) to the number of messages processed.
      - 'senders': Counter of sender addresses.
      - 'recipients': Counter of recipient addresses.
    """
    try:
        if '-' in target_date:
            dt_target = datetime.datetime.strptime(target_date, '%Y-%m-%d')
        else:
            dt_target = datetime.datetime.strptime(target_date, '%Y%m%d')
    except ValueError:
        print("Error: Date must be in YYYYMMDD or YYYY-MM-DD format.", file=sys.stderr)
        sys.exit(1)

    # For matching the log file, extract the month abbreviation (e.g., "Nov") and
    # the day number (space-padded if necessary; Postfix logs do not zero-pad the day).
    month_str = dt_target.strftime("%b")
    day_str = str(dt_target.day)

    header_regex = re.compile(r"^{}[\s]+{}\b".format(re.escape(month_str), re.escape(day_str)))

    summary = {
        'sent': 0,
        'deferred': 0,
        'bounced': 0,
        'rejected': 0,
        'connections': 0,
        'per_hour': Counter(),
        'senders': Counter(),
        'recipients': Counter(),
    }

    # Regex patterns for various log fields.
    hour_regex = re.compile(r"^[A-Za-z]{3}\s+\d+\s+(\d{2}):")
    status_sent = re.compile(r'status=sent')
    status_deferred = re.compile(r'status=deferred')
    status_bounced = re.compile(r'status=bounced')
    reject_pattern = re.compile(r'reject:')
    from_regex = re.compile(r'from=<([^>]+)>')
    to_regex = re.compile(r'to=<([^>]+)>')

    with open(logfile, 'r') as f:
        for line in f:
            if not header_regex.search(line):
                continue # Skip lines not matching the target date

            # Count connection attempts.
            if "connect from" in line:
                summary['connections'] += 1

            # Extract hour information.
            hr_match = hour_regex.search(line)
            if hr_match:
                hr = hr_match.group(1)
                summary['per_hour'][hr] += 1

            # Count different statuses and events.
            if status_sent.search(line):
                summary['sent'] += 1
            if status_deferred.search(line):
                summary['deferred'] += 1
            if status_bounced.search(line):
                summary['bounced'] += 1
            if reject_pattern.search(line):
                summary['rejected'] += 1

            # Record sender and recipient information.
            from_match = from_regex.search(line)
            if from_match:
                summary['senders'][from_match.group(1)] += 1
            to_match = to_regex.search(line)
            if to_match:
                summary['recipients'][to_match.group(1)] += 1

    return summary


def generate_text_report(summary, target_date, exclude_hourly=False):
    """
    Generate a textual report based on the summary dictionary.

    If exclude_hourly is True, the "Messages per Hour" section is omitted.
    """
    total_messages = summary['sent'] + summary['deferred'] + summary['bounced']
    report_lines = []
    report_lines.append(f"Postfix Mail Summary for {target_date}")
    report_lines.append("=" * 40)
    report_lines.append(f"Total messages processed: {total_messages}")
    report_lines.append(f"  Sent     : {summary['sent']}")
    report_lines.append(f"  Deferred : {summary['deferred']}")
    report_lines.append(f"  Bounced  : {summary['bounced']}")
    report_lines.append(f"  Rejected : {summary['rejected']}")
    report_lines.append("")
    report_lines.append(f"Total connection attempts: {summary['connections']}")
    report_lines.append("")
    if not exclude_hourly:
        report_lines.append("Messages per Hour:")
        for hr in sorted(summary['per_hour']):
            report_lines.append(f"  {hr}:00 - {summary['per_hour'][hr]} messages")
        report_lines.append("")
    if summary['senders']:
        report_lines.append("Top 5 Senders:")
        for sender, count in summary['senders'].most_common(5):
            report_lines.append(f"  {sender}: {count}")
        report_lines.append("")
    if summary['recipients']:
        report_lines.append("Top 5 Recipients:")
        for recipient, count in summary['recipients'].most_common(5):
            report_lines.append(f"  {recipient}: {count}")

    return "\n".join(report_lines)


def create_hourly_plot(summary, target_date):
    """
    Generate a bar chart (using matplotlib) showing the number of messages processed per hour.
    Returns a BytesIO buffer containing the image in PNG format.
    """
    # Ensure all 24 hours are present (00-23).
    hours = [f"{i:02d}" for i in range(24)]
    counts = [summary['per_hour'].get(hr, 0) for hr in hours]

    fig, ax = plt.subplots()
    ax.bar(hours, counts)
    ax.set_xlabel('Hour of the Day')
    ax.set_ylabel('Message Count')
    ax.set_title(f'Mail Activity by Hour for {target_date}')

    buf = io.BytesIO()
    plt.tight_layout()
    plt.savefig(buf, format='png')
    plt.close(fig)
    buf.seek(0)
    return buf


def send_email_report(sender, recipient, subject, text_report, image_buffer):
    """
    Send an email with the provided text report and an inline PNG image.

    The email contains:
      - A plain text part.
      - An HTML part in which the report is displayed using a monospace font.

    This example uses a local SMTP server.
    """
    # Create a multipart message with both text and HTML parts.
    msg_root = MIMEMultipart('related')
    msg_root['Subject'] = subject
    msg_root['From'] = sender
    msg_root['To'] = recipient

    msg_alternative = MIMEMultipart('alternative')
    msg_root.attach(msg_alternative)

    # Plain text part.
    plain = MIMEText(text_report, 'plain')
    msg_alternative.attach(plain)

    # HTML part: rendering the report in a monospace font.
    html_content = f"""\
<html>
  <body style="background-color:white;color:black;font-size:1em;">
    <p><pre style="font-family:monospace;">{text_report}</pre></p>
    <div><h5><b>Hourly Mail Activity:</b></h5>
    <img src="cid:image1" alt="Hourly Chart"></div>
  </body>
</html>
"""
    html = MIMEText(html_content, 'html')
    msg_alternative.attach(html)

    # Attach the image inline.
    img = MIMEImage(image_buffer.read(), name="hourly.png")
    img.add_header('Content-ID', '<image1>')
    msg_root.attach(img)

    try:
        with smtplib.SMTP('localhost') as smtp:
            smtp.send_message(msg_root)
        print(f"Email successfully sent to {recipient}.")
    except Exception as e:
        print("Error sending email:", e)


def main():
    args = parse_args()

    summary = parse_log_file(args.logfile, args.date)
    total_messages = summary['sent'] + summary['deferred'] + summary['bounced']

    # Optionally skip report generation if no mail was processed.
    if args.skip_no_mail and total_messages == 0:
        print(f"No mail processed on {args.date}; skipping report generation.")
        sys.exit(0)

    # Generate the textual report; exclude hourly details if requested.
    text_report = generate_text_report(summary, args.date, exclude_hourly=args.exclude_hourly)
    print(text_report)

    # Generate the graphical report (bar chart).
    image_buffer = create_hourly_plot(summary, args.date)

    # Send email if an email address is provided; otherwise, save the image locally.
    if args.email:
        subject = f"Postfix Mail Report for {args.date}"
        send_email_report(args.sender, args.email, subject, text_report, image_buffer)
    else:
        output_image = f"mail_report_{args.date}.png"
        with open(output_image, 'wb') as out_f:
            out_f.write(image_buffer.getbuffer())
        print(f"Graphical report saved as {output_image}.")


if __name__ == '__main__':
    main()
